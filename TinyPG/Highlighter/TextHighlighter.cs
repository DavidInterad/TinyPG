// Generated by TinyPG v1.4

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace TinyPG.Highlighter
{
    // Summary:
    //     System.EventArgs is the base class for classes containing event data.
    [Serializable]
    [ComVisible(true)]
    public class ContextSwitchEventArgs : EventArgs
    {
        public readonly ParseNode PreviousContext;
        public readonly ParseNode NewContext;

        // Summary:
        //     Initializes a new instance of the System.EventArgs class.
        public ContextSwitchEventArgs(ParseNode prevContext, ParseNode nextContext)
        {
            PreviousContext = prevContext;
            NewContext = nextContext;
        }
    }

    // delegate for firing context switch events
    public delegate void ContextSwitchEventHandler(object sender, ContextSwitchEventArgs e);

    /// <summary>
    /// Takes control over the RichTextBox and will color the text according to the rules of the parser and the scanner
    /// this control extender will also support Undo/Redo functionality.
    /// </summary>
    public class TextHighlighter : IDisposable
    {
        private class UndoItem
        {
            /// <summary>
            /// contains the information for an undo/redo action
            /// </summary>
            /// <param name="text">the full text to be undone/redone</param>
            /// <param name="position">position of the caret after the un/redo action</param>
            /// <param name="scroll">position of the scrollbars after un/redo action</param>
            public UndoItem(string text, int position, Point scroll)
            {
                Text = text;
                Position = position;
                ScrollPosition = scroll;
            }

            public readonly string Text;
            public readonly int Position;
            public Point ScrollPosition;
        }


        // some winAPIs required
        [DllImport("user32", CharSet = CharSet.Auto)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, IntPtr lParam);

        [DllImport("user32.dll")]
        private static extern bool PostMessageA(IntPtr hWnd, int nBar, int wParam, int lParam);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern int GetScrollPos(int hWnd, int nBar);

        [DllImport("user32.dll")]
        private static extern int SetScrollPos(IntPtr hWnd, int nBar, int nPos, bool bRedraw);

        private const int WM_SETREDRAW = 0x000B;
        private const int WM_USER = 0x400;
        private const int EM_GETEVENTMASK = (WM_USER + 59);
        private const int EM_SETEVENTMASK = (WM_USER + 69);
        private const int SB_HORZ = 0x0;
        private const int SB_VERT = 0x1;
        private const int WM_HSCROLL = 0x114;
        private const int WM_VSCROLL = 0x115;
        private const int SB_THUMBPOSITION = 4;
        private const int UNDO_BUFFER = 100;

        private int HScrollPos
        {
            get => GetScrollPos((int)TextBox.Handle, SB_HORZ);
            set
            {
                SetScrollPos(TextBox.Handle, SB_HORZ, value, true);
                PostMessageA(TextBox.Handle, WM_HSCROLL, SB_THUMBPOSITION + 0x10000 * value, 0);
            }
        }

        private int VScrollPos
        {
            get => GetScrollPos((int)TextBox.Handle, SB_VERT);
            set
            {
                SetScrollPos(TextBox.Handle, SB_VERT, value, true);
                PostMessageA(TextBox.Handle, WM_VSCROLL, SB_THUMBPOSITION + 0x10000 * value, 0);
            }
        }

        // public shared members
        public ParseTree Tree;
        public readonly RichTextBox TextBox;

        // private members
        private readonly Parser _parser;
        private readonly Scanner _scanner;
        private IntPtr _stateLocked = IntPtr.Zero;

        private int _undoIndex = -1;
        private List<UndoItem> _undoList;

        private ParseNode _currentContext;
        public event ContextSwitchEventHandler SwitchContext;

        private readonly Thread _threadAutoHighlight;


        private void Do(string text, int position)
        {
            if (_stateLocked != IntPtr.Zero)
            {
                return;
            }

            var ua = new UndoItem(text, position, new Point(HScrollPos, VScrollPos));
            _undoList.RemoveRange(_undoIndex, _undoList.Count - _undoIndex);
            _undoList.Add(ua);
            if (_undoList.Count > UNDO_BUFFER)
            {
                _undoList.RemoveAt(0);
            }

            // make undo/redo a little smarter, remove single strokes
            // reducing nr of undo states
            if (_undoList.Count > 7)
            {
                var canRemove = true;
                var nextItem = ua;
                for (var i = 0; i < 6; i++)
                {
                    var prevItem = _undoList[_undoList.Count - 2 - i];
                    canRemove &= Math.Abs(prevItem.Text.Length - nextItem.Text.Length) <= 1 && Math.Abs(prevItem.Position - nextItem.Position) <= 1;
                    nextItem = prevItem;
                }
                if (canRemove)
                {
                    _undoList.RemoveRange(_undoList.Count - 6, 5);
                }
            }

            _undoIndex = _undoList.Count;
        }

        public void ClearUndo()
        {
            _undoList = new List<UndoItem>();
            _undoIndex = 0;
        }

        public void Undo()
        {
            if (!CanUndo)
            {
                return;
            }

            _undoIndex--;
            if (_undoIndex < 1)
            {
                _undoIndex = 1;
            }

            // implement undo action here
            var ua = _undoList[_undoIndex-1];
            RestoreState(ua);
        }

        public void Redo()
        {
            if (!CanRedo)
            {
                return;
            }

            _undoIndex++;
            if (_undoIndex > _undoList.Count)
            {
                _undoIndex = _undoList.Count;
            }

            var ua = _undoList[_undoIndex-1];
            RestoreState(ua);
        }

        private void RestoreState(UndoItem item)
        {
            Lock();
            // restore state
            TextBox.Rtf = item.Text;
            TextBox.Select(item.Position, 0);
            HScrollPos = item.ScrollPosition.X;
            VScrollPos = item.ScrollPosition.Y;

            Unlock();
        }

        public bool CanUndo => _undoIndex > 0;

        public bool CanRedo => _undoIndex < _undoList.Count;

        public TextHighlighter(RichTextBox textBox, Scanner scanner, Parser parser)
        {
            TextBox = textBox;
            _scanner = scanner;
            _parser = parser;

            ClearUndo();

            //Tree = Parser.Parse(TextBox.Text);
            TextBox.TextChanged += Textbox_TextChanged;
            textBox.KeyDown += textbox_KeyDown;
            TextBox.SelectionChanged += Textbox_SelectionChanged;
            TextBox.Disposed += Textbox_Disposed;

            SwitchContext = null;
            _currentContext = Tree;

            _threadAutoHighlight = new Thread(AutoHighlightStart);
            _threadAutoHighlight.Start();
        }


        public void Lock()
        {
            // Stop redrawing:
            SendMessage(TextBox.Handle, WM_SETREDRAW, 0, IntPtr.Zero);
            // Stop sending of events:
            _stateLocked = SendMessage(TextBox.Handle, EM_GETEVENTMASK, 0, IntPtr.Zero);
            // change colors and stuff in the RichTextBox
        }

        public void Unlock()
        {
            // turn on events
            SendMessage(TextBox.Handle, EM_SETEVENTMASK, 0, _stateLocked);
            // turn on redrawing
            SendMessage(TextBox.Handle, WM_SETREDRAW, 1, IntPtr.Zero);

            _stateLocked = IntPtr.Zero;
            TextBox.Invalidate();
        }

        void textbox_KeyDown(object sender, KeyEventArgs e)
        {
            // undo/redo
            switch (e.KeyValue)
            {
                // CTRL-Y
                case 89 when e.Control:
                    Redo();
                    break;
                // CTRL-Z
                case 90 when e.Control:
                    Undo();
                    break;
            }
        }

        void Textbox_TextChanged(object sender, EventArgs e)
        {
            if (_stateLocked != IntPtr.Zero) return;

            Do(TextBox.Rtf, TextBox.SelectionStart);

            HighlightText();
        }

        void Textbox_SelectionChanged(object sender, EventArgs e)
        {
            if (_stateLocked != IntPtr.Zero)
            {
                return;
            }

            if (SwitchContext == null)
            {
                return;
            }
            var newContext = GetCurrentContext();

            if (_currentContext == null)
            {
                _currentContext = newContext;
            }

            if (newContext == null)
            {
                return;
            }

            if (newContext.Token.Type != _currentContext.Token.Type)
            {
                SwitchContext.Invoke(this, new ContextSwitchEventArgs(_currentContext, newContext));
                _currentContext = newContext;
            }
        }

        /// <summary>
        /// this handy function returns the section in which the user is editing currently
        /// </summary>
        /// <returns></returns>
        public ParseNode GetCurrentContext() => FindNode(Tree, TextBox.SelectionStart);

        private static ParseNode FindNode(ParseNode node, int posStart)
        {
            if (node == null)
            {
                return null;
            }

            if (node.Token.StartPos > posStart || node.Token.StartPos + node.Token.Length < posStart)
            {
                return null;
            }

            foreach (var n in node.Nodes.Where(n => n.Token.StartPos <= posStart && n.Token.StartPos + n.Token.Length >= posStart))
            {
                return FindNode(n, posStart);
            }

            return node;
        }

        /// <summary>
        /// use HighlightText to start the text highlight process from the caller's thread.
        /// this method is not used internally.
        /// </summary>
        public void HighlightText()
        {
            lock (TreeLock)
            {
                _textChanged = true;
                _currentText = TextBox.Text;
            }
        }

        // highlight the text (used internally only)
        private void HighlightTextInternal()
        {
            Lock();

            var hscroll = HScrollPos;
            var vscroll = VScrollPos;

            var selstart = TextBox.SelectionStart;

            HighlightTextCore();

            TextBox.Select(selstart,0);

            HScrollPos = hscroll;
            VScrollPos = vscroll;

            Unlock();
        }

        public bool IsHighlighting { get; private set; }

        /// <summary>
        /// this method should be used only by HighlightText or RestoreState methods
        /// </summary>
        private void HighlightTextCore()
        {
            //Tree = Parser.Parse(TextBox.Text);
            if (Tree == null)
            {
                return;
            }

            var sb = new StringBuilder();

            var start = Tree.Nodes[0];
            HighlightNode(start, sb);

            // append any trailing skipped tokens that were scanned
            foreach (var skipToken in _scanner.Skipped)
            {
                HighlightToken(skipToken, sb);
                sb.Append(skipToken.Text.Replace(@"\", @"\\").Replace("{", @"\{").Replace("}", @"\}").Replace("\n", "\\par\n"));
            }

            // NOTE: if you do not need unicode characters and you need a little bit more performance
            // you can comment out the following line:
            sb = Unicode(sb);     // <--- without this, unicode characters will be garbled after highlighting

            AddRtfHeader(sb);
            AddRtfEnd(sb);

            IsHighlighting = true;
            TextBox.Rtf = sb.ToString();
            IsHighlighting = false;
        }

                /// <summary>
        /// added function to convert unicode characters in the StringBuilder to rtf unicode escapes
        /// </summary>
        public StringBuilder Unicode(StringBuilder sb)
        {
            var uc = new StringBuilder();
            for (var i = 0; i <= sb.Length - 1; i++)
            {
                var c = sb[i];

                if (c < 127)
                {
                    uc.Append(c);
                }
                else
                {
                    uc.Append($"\\u{(int)c}?");
                }
            }
            return uc;
        }

        // thread start for the automatic highlighting
        public static object TreeLock = new object(); // made specifically public for TinyPG main form
        private bool _isDisposing;
        private bool _textChanged;
        private string _currentText;

        private void AutoHighlightStart()
        {
            var currentText = "";
            while (!_isDisposing)
            {
                bool textChanged;
                lock (TreeLock)
                {
                    textChanged = _textChanged;
                    if (_textChanged)
                    {
                        _textChanged = false;
                        currentText = _currentText;
                    }
                }
                if (!textChanged)
                {
                    Thread.Sleep(200);
                    continue;
                }

                var tree = _parser.Parse(currentText, string.Empty);
                lock (TreeLock)
                {
                    if (_textChanged)
                    {
                        continue;
                    }

                    Tree = tree; // assign new tree
                }

                TextBox.Invoke(new MethodInvoker(HighlightTextInternal));
            }
        }


        /// <summary>
        /// inserts the RTF codes to highlight text blocks
        /// </summary>
        /// <param name="node">the node to highlight, will be appended to sb</param>
        /// <param name="sb">the final output string</param>
        private static void HighlightNode(ParseNode node, StringBuilder sb)
        {
            if (node.Nodes.Count == 0)
            {
                if (node.Token.Skipped != null)
                {
                    foreach(var skipToken in node.Token.Skipped)
                    {
                        HighlightToken(skipToken, sb);
                        sb.Append(skipToken.Text.Replace(@"\", @"\\").Replace("{", @"\{").Replace("}", @"\}").Replace("\n", "\\par\n"));
                    }
                }

                HighlightToken(node.Token, sb);
                sb.Append(node.Token.Text.Replace(@"\", @"\\").Replace("{", @"\{").Replace("}", @"\}").Replace("\n", "\\par\n"));
                sb.Append(@"}");
            }

            foreach (var n in node.Nodes)
            {
                HighlightNode(n, sb);
            }
        }

        /// <summary>
        /// inserts the RTF codes to highlight text blocks
        /// </summary>
        /// <param name="token">the token to highlight, will be appended to sb</param>
        /// <param name="sb">the final output string</param>
        private static void HighlightToken(Token token, StringBuilder sb)
        {
            switch (token.Type)
            {
                    case TokenType.GRAMMARCOMMENTLINE:
                        sb.Append(@"{{\cf1 ");
                        break;
                    case TokenType.GRAMMARCOMMENTBLOCK:
                        sb.Append(@"{{\cf2 ");
                        break;
                    case TokenType.DIRECTIVESTRING:
                        sb.Append(@"{{\cf3 ");
                        break;
                    case TokenType.DIRECTIVEKEYWORD:
                        sb.Append(@"{{\cf4 ");
                        break;
                    case TokenType.DIRECTIVEOPEN:
                        sb.Append(@"{{\cf5 ");
                        break;
                    case TokenType.DIRECTIVECLOSE:
                        sb.Append(@"{{\cf6 ");
                        break;
                    case TokenType.ATTRIBUTEKEYWORD:
                        sb.Append(@"{{\cf7 ");
                        break;
                    case TokenType.CS_KEYWORD:
                        sb.Append(@"{{\cf8 ");
                        break;
                    case TokenType.VB_KEYWORD:
                        sb.Append(@"{{\cf9 ");
                        break;
                    case TokenType.DOTNET_KEYWORD:
                        sb.Append(@"{{\cf10 ");
                        break;
                    case TokenType.DOTNET_TYPES:
                        sb.Append(@"{{\cf11 ");
                        break;
                    case TokenType.CS_COMMENTLINE:
                        sb.Append(@"{{\cf12 ");
                        break;
                    case TokenType.CS_COMMENTBLOCK:
                        sb.Append(@"{{\cf13 ");
                        break;
                    case TokenType.CS_STRING:
                        sb.Append(@"{{\cf14 ");
                        break;
                    case TokenType.VB_COMMENTLINE:
                        sb.Append(@"{{\cf15 ");
                        break;
                    case TokenType.VB_COMMENTBLOCK:
                        sb.Append(@"{{\cf16 ");
                        break;
                    case TokenType.VB_STRING:
                        sb.Append(@"{{\cf17 ");
                        break;
                    case TokenType.DOTNET_COMMENTLINE:
                        sb.Append(@"{{\cf18 ");
                        break;
                    case TokenType.DOTNET_COMMENTBLOCK:
                        sb.Append(@"{{\cf19 ");
                        break;
                    case TokenType.DOTNET_STRING:
                        sb.Append(@"{{\cf20 ");
                        break;
                    case TokenType.CODEBLOCKOPEN:
                        sb.Append(@"{{\cf21 ");
                        break;
                    case TokenType.CODEBLOCKCLOSE:
                        sb.Append(@"{{\cf22 ");
                        break;
                    case TokenType.GRAMMARKEYWORD:
                        sb.Append(@"{{\cf23 ");
                        break;
                    case TokenType.GRAMMARARROW:
                        sb.Append(@"{{\cf24 ");
                        break;
                    case TokenType.GRAMMARSTRING:
                        sb.Append(@"{{\cf25 ");
                        break;

                default:
                    sb.Append(@"{{\cf0 ");
                    break;
            }
        }

        // define the color palette to be used here
        private static void AddRtfHeader(StringBuilder sb)
        {
            sb.Insert(0, @"{\rtf1\ansi\deff0{\fonttbl{\f0\fnil\fcharset0 Consolas;}}{\colortbl;\red0\green128\blue0;\red0\green128\blue0;\red255\green0\blue0;\red128\green0\blue255;\red128\green0\blue128;\red128\green0\blue128;\red43\green145\blue202;\red0\green0\blue255;\red255\green0\blue0;\red0\green0\blue255;\red43\green145\blue202;\red0\green128\blue0;\red0\green128\blue0;\red163\green21\blue21;\red0\green128\blue0;\red0\green128\blue0;\red163\green21\blue21;\red0\green128\blue0;\red0\green128\blue0;\red163\green21\blue21;\red128\green0\blue128;\red128\green0\blue128;\red0\green0\blue255;\red128\green0\blue128;\red163\green21\blue21;}\viewkind4\uc1\pard\lang1033\f0\fs20");
        }

        private static void AddRtfEnd(StringBuilder sb)
        {
            sb.Append("}");
        }

        private void Textbox_Disposed(object sender, EventArgs e)
        {
            Dispose();
        }

        #region IDisposable Members

        public void Dispose()
        {
            _isDisposing = true;
            _threadAutoHighlight.Join(1000);
            if (_threadAutoHighlight.IsAlive)
            {
                _threadAutoHighlight.Abort();
            }
        }

        #endregion
    }
}
