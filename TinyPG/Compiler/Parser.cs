// Generated by TinyPG v1.4

namespace TinyPG
{
	#region Parser

	public class Parser
	{
		private readonly Scanner _scanner;
		private ParseTree _tree;

		public Parser(Scanner scanner)
		{
			_scanner = scanner;
		}

		public ParseTree Parse(string input, string fileName)
		{
			_tree = new ParseTree();
			return Parse(input, fileName, _tree);
		}

		public ParseTree Parse(string input, string fileName, ParseTree tree)
		{
			_scanner.Init(input, fileName);

			_tree = tree;
			ParseStart(tree);
			tree.Skipped = _scanner.Skipped;

			return tree;
		}

		private void ParseStart(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Start), "Start");
			parent.Nodes.Add(node);

			var tok = _scanner.LookAhead(TokenType.DIRECTIVEOPEN);
			while (tok.Type == TokenType.DIRECTIVEOPEN)
			{
				ParseDirective(node);
				tok = _scanner.LookAhead(TokenType.DIRECTIVEOPEN);
			}

			tok = _scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER);
			while (tok.Type == TokenType.SQUAREOPEN
				|| tok.Type == TokenType.IDENTIFIER)
			{
				ParseExtProduction(node);
				tok = _scanner.LookAhead(TokenType.SQUAREOPEN, TokenType.IDENTIFIER);
			}


			tok = _scanner.Scan(TokenType.EOF);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.EOF)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF, 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseDirective(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Directive), "Directive");
			parent.Nodes.Add(node);

			var tok = _scanner.Scan(TokenType.DIRECTIVEOPEN);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.DIRECTIVEOPEN)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVEOPEN, 0x1001, tok));
				return;
			}


			tok = _scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
				return;
			}


			tok = _scanner.LookAhead(TokenType.IDENTIFIER);
			while (tok.Type == TokenType.IDENTIFIER)
			{
				ParseNameValue(node);
				tok = _scanner.LookAhead(TokenType.IDENTIFIER);
			}


			tok = _scanner.Scan(TokenType.DIRECTIVECLOSE);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.DIRECTIVECLOSE)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIRECTIVECLOSE, 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseNameValue(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.NameValue), "NameValue");
			parent.Nodes.Add(node);

			var tok = _scanner.Scan(TokenType.IDENTIFIER);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
				return;
			}


			tok = _scanner.Scan(TokenType.ASSIGN);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.ASSIGN)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN, 0x1001, tok));
				return;
			}


			tok = _scanner.Scan(TokenType.STRING);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.STRING)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseExtProduction(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.ExtProduction), "ExtProduction");
			parent.Nodes.Add(node);

			var tok = _scanner.LookAhead(TokenType.SQUAREOPEN);
			while (tok.Type == TokenType.SQUAREOPEN)
			{
				ParseAttribute(node);
				tok = _scanner.LookAhead(TokenType.SQUAREOPEN);
			}


			ParseProduction(node);

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseAttribute(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Attribute), "Attribute");
			parent.Nodes.Add(node);

			var tok = _scanner.Scan(TokenType.SQUAREOPEN);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.SQUAREOPEN)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN, 0x1001, tok));
				return;
			}


			tok = _scanner.Scan(TokenType.IDENTIFIER);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
				return;
			}


			tok = _scanner.LookAhead(TokenType.BRACKETOPEN);
			if (tok.Type == TokenType.BRACKETOPEN)
			{
				tok = _scanner.Scan(TokenType.BRACKETOPEN);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.BRACKETOPEN)
				{
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN, 0x1001, tok));
					return;
				}

				tok = _scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX);
				if (tok.Type == TokenType.INTEGER
					|| tok.Type == TokenType.DOUBLE
					|| tok.Type == TokenType.STRING
					|| tok.Type == TokenType.HEX)
				{
					ParseParams(node);
				}


				tok = _scanner.Scan(TokenType.BRACKETCLOSE);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.BRACKETCLOSE)
				{
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE, 0x1001, tok));
					return;
				}
			}


			tok = _scanner.Scan(TokenType.SQUARECLOSE);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.SQUARECLOSE)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE, 0x1001, tok));
				return;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseParams(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Params), "Params");
			parent.Nodes.Add(node);

			ParseParam(node);


			var tok = _scanner.LookAhead(TokenType.COMMA);
			while (tok.Type == TokenType.COMMA)
			{
				tok = _scanner.Scan(TokenType.COMMA);
				var n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.COMMA)
				{
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA, 0x1001, tok));
					return;
				}


				ParseParam(node);
				tok = _scanner.LookAhead(TokenType.COMMA);
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseParam(ParseNode parent)
		{
			ParseNode n;
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Param), "Param");
			parent.Nodes.Add(node);

			var tok = _scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.STRING, TokenType.HEX);
			switch (tok.Type)
			{
				case TokenType.INTEGER:
					tok = _scanner.Scan(TokenType.INTEGER);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.INTEGER)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER, 0x1001, tok));
						return;
					}
					break;
				case TokenType.DOUBLE:
					tok = _scanner.Scan(TokenType.DOUBLE);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.DOUBLE)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE, 0x1001, tok));
						return;
					}
					break;
				case TokenType.STRING:
					tok = _scanner.Scan(TokenType.STRING);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.STRING)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
						return;
					}
					break;
				case TokenType.HEX:
					tok = _scanner.Scan(TokenType.HEX);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.HEX)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HEX, 0x1001, tok));
						return;
					}
					break;
				default:
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseProduction(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Production), "Production");
			parent.Nodes.Add(node);

			var tok = _scanner.Scan(TokenType.IDENTIFIER);
			var n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.IDENTIFIER)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
				return;
			}


			tok = _scanner.Scan(TokenType.ARROW);
			n = node.CreateNode(tok, tok.ToString());
			node.Token.UpdateRange(tok);
			node.Nodes.Add(n);
			if (tok.Type != TokenType.ARROW)
			{
				_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARROW, 0x1001, tok));
				return;
			}


			ParseRule(node);


			tok = _scanner.LookAhead(TokenType.CODEBLOCK, TokenType.SEMICOLON);
			switch (tok.Type)
			{
				case TokenType.CODEBLOCK:
					tok = _scanner.Scan(TokenType.CODEBLOCK);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.CODEBLOCK)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CODEBLOCK, 0x1001, tok));
						return;
					}
					break;
				case TokenType.SEMICOLON:
					tok = _scanner.Scan(TokenType.SEMICOLON);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.SEMICOLON)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON, 0x1001, tok));
						return;
					}
					break;
				default:
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseRule(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Rule), "Rule");
			parent.Nodes.Add(node);

			var tok = _scanner.LookAhead(TokenType.STRING, TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
			switch (tok.Type)
			{
				case TokenType.STRING:
					tok = _scanner.Scan(TokenType.STRING);
					var n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.STRING)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING, 0x1001, tok));
						return;
					}
					break;
				case TokenType.IDENTIFIER:
				case TokenType.BRACKETOPEN:
					ParseSubrule(node);
					break;
				default:
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseSubrule(ParseNode parent)
		{
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Subrule), "Subrule");
			parent.Nodes.Add(node);

			ParseConcatRule(node);


			var tok = _scanner.LookAhead(TokenType.PIPE);
			while (tok.Type == TokenType.PIPE)
			{


				tok = _scanner.Scan(TokenType.PIPE);
				var n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.PIPE)
				{
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PIPE, 0x1001, tok));
					return;
				}


				ParseConcatRule(node);
				tok = _scanner.LookAhead(TokenType.PIPE);
			}

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseConcatRule(ParseNode parent)
		{
			Token tok;
			var node = parent.CreateNode(_scanner.GetToken(TokenType.ConcatRule), "ConcatRule");
			parent.Nodes.Add(node);

			do
			{
				ParseSymbol(node);
				tok = _scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
			} while (tok.Type == TokenType.IDENTIFIER || tok.Type == TokenType.BRACKETOPEN);

			parent.Token.UpdateRange(node.Token);
		}

		private void ParseSymbol(ParseNode parent)
		{
			ParseNode n;
			var node = parent.CreateNode(_scanner.GetToken(TokenType.Symbol), "Symbol");
			parent.Nodes.Add(node);

			var tok = _scanner.LookAhead(TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
			switch (tok.Type)
			{
				case TokenType.IDENTIFIER:
					tok = _scanner.Scan(TokenType.IDENTIFIER);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.IDENTIFIER)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER, 0x1001, tok));
						return;
					}
					break;
				case TokenType.BRACKETOPEN:


					tok = _scanner.Scan(TokenType.BRACKETOPEN);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.BRACKETOPEN)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN, 0x1001, tok));
						return;
					}


					ParseSubrule(node);


					tok = _scanner.Scan(TokenType.BRACKETCLOSE);
					n = node.CreateNode(tok, tok.ToString());
					node.Token.UpdateRange(tok);
					node.Nodes.Add(n);
					if (tok.Type != TokenType.BRACKETCLOSE)
					{
						_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE, 0x1001, tok));
						return;
					}
					break;
				default:
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
					break;
			}


			tok = _scanner.LookAhead(TokenType.UNARYOPER);
			if (tok.Type == TokenType.UNARYOPER)
			{
				tok = _scanner.Scan(TokenType.UNARYOPER);
				n = node.CreateNode(tok, tok.ToString());
				node.Token.UpdateRange(tok);
				node.Nodes.Add(n);
				if (tok.Type != TokenType.UNARYOPER)
				{
					_tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNARYOPER, 0x1001, tok));
					return;
				}
			}

			parent.Token.UpdateRange(node.Token);
		}
	}

	#endregion Parser
}
